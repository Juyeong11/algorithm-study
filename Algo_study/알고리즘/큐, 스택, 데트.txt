큐, 스택, 데크

큐
- 한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 꺼낼 수 있습니다.
- 선입선출

스택
- 한쪽 끝에서만 자료를 넣고 뺄 수 잇습니다.
- 후입선출
- 컴퓨터는 내부적으로 스택을 사용해 함수들의 문맥을 관리합니다.

데크
- 양쪽 끝에서 자료들을 넣고 뺄 수 있는 자료 구조를 말합니다.



연결리스트를 이용한 구현

- 모든 연산이 상수시간에 구현
- 노드의 할당과 삭제 포인터 따라가는 데 드는 시간이 걸림

동적 배열을 이용한 구현

- head와 tail을 지정해 환형으로 돌아가면서 구현함


활용

조세푸스 문제
- 큐의 첫 번째 사람이 나와서 죽고
- 큐의 맨 앞에 있는 사람을 맨 뒤로 보내는 작업을 k-1번 반복한다.

울타리 자르기 문제
- 스위핑 알고리즘과 스택을 결합해 효율적으로 풀 수 있다.

최대 넓이 사각형의 조건
- 높이가 같은 판자가 하나는 있다. i번 째판자
- 사각형의 왼쪽 끝과 오른쪽 끝은 높이가 같은 판자보다 낮은 판자들로 막혀 있다.
  이때 막은 판자를 left[i]와 right[i]로 정한다.
 
0번 판자부터 1번 판자와 비교하면서 경우의 수를 생각해본다.
h[0]>h[1]
- right[0] == 1 이다.
- 어떤 판자에 대해서도 left[i]가 0이 될 경우는 없으므로 0번 판자는 지우고 left[1]은 -1임을 알 수 있다.
h[0]==h[1]
- 위의 경우와 똑같이 처리
h[0]<h[1]
- 0번 판자가 1번 판자의 최대 사각형갈 길을 막고 있다. 고로 left[1]은 0이다.

이 과정을 일반화 하면 스위핑 알고리즘을 얻을 수 있다.

vector<int> h;

int solveStack()
{
	stack<int> remaining;//남아있는 판자들의 위치를 저장
	h.push_back(0);
	int ret = 0;
	for(int i = 0; i < h.size(); ++i)
	{
		while(!remaining.empty() && h[remaining.top] >= i)
		{
			int j = remaining.top();
			int width = -1; // j번째 판자 왼쪽에 판자가 하나도 안 남아 있는 경우
			
			if(remaining.empty())//
				width = i;
			else
				width = (i - remaining.top() - 1);
			ret = max(ret, h[j] * width);

		}
	remaining.push(i);
	}

	return ret;
}