
탐욕적인 알고리즘은 우리가 원하는 답을 재귀 호출과 똑같이 여러 개의 조각으로 쪼개고,
각 단게마다 답의 한 부분을 만들어 간다는 점에서 완전 탐색,동적 계회법알고리즘과 다를 것이 없다.
그러나 탐욕법은 각 단계마다 지금 당장 가장 좋은 방법만을 선택한다.

탐욕적 알고리즘은 많은 경우 최적해를 찾지 못한다. 따라서 탐욕적 알고리즘이 사용되는 경우는 크게 두 가지로 정리된다.

- 탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제를 만난 경우, 탐욕법은 독적 계획법보다 수행 시간이 훨씬 빠르기 때문에 유용하다.

- 시간이나 공간적 제약으로 인해 다른 방법으로 최적해를 찾기 너무 어렵다면 최적해 대신 근사해를 찾는 것으로 타협 할 경우

문제 회의실 예약

서로의 팀이 시간이 곂치지 않게 회의를 선택할 때 최대로 선택할 수 있는 개수

* 가장 종료시간이 빠른 회의를 포함하는 최적해가 반드시 존재 한다.

#include<iostream>
#include<vector>
using namespace std;

int main()
{
	
}

int n;
int begin[100], end[100];
int schedule()
{
	vector<pair<int,int>> order;
	
	for(int i=0;i<n;++i)
		order.push_back(make_pair(end[i],begin[i]));
	sort(order.begin(), order.end());
	
	//  회의가 시작할 수 있는 가장 빠른 시간
	int earliest = 0;
	//  지금까지 선택한 회의의 수
	int selected = 0;
	
	// 각 부분에서 제일 일찍 끝나는 회의를 찾는다.
	for(int i = 0; i < order.size(); ++i)
	{
		int meetingBegin = order[i].second, meetingEnd = order[i].first;
		
		if(earliest <= meetingBegin)
		{
			earliest = meetingEnd;
			++selected;
		}
	}
	return selected;
}
//이 문제는 동적 계획법으로도 풀 수 있다.
//schedule(idx) = meeting[idx] 혹은 그 이전에 끝나는 회의들 중 선택할 수 있는 최대 회의의 수
//
//schedule()은 매 단계에서 meeting[idx]를 선택할지 여부를 결정합니다.
//idx번 회의가 시작하기 전에 끝나는 회의들 중 마지막 회의의 번호를before[idx]에 저장했다고 하면 
//선택하지 않을경우의 최적해는 schedule(idx-1)로 선택할 경우의 답은 1+schedule(before[idx])로 재귀적으로 표현할 수 있다